package CM.test;

/*Generated by MPS */

import org.lwjgl.util.vector.Matrix4f;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.GL30;
import org.lwjgl.opengl.GL20;
import org.lwjgl.opengl.GL13;

public class Renderer {

  private Matrix4f projMatrix;
  private static final float FOV = 70;
  private static final float nearPlane = 0.1f;
  private static final float farPlane = 1000;

  public Renderer(Shader s) {
    createProjectionMatrix();
    s.start();
    s.loadProjMatrix(projMatrix);
    s.stop();
  }

  public void prepare() {
    GL11.glEnable(GL11.GL_DEPTH_TEST);
    GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
    GL11.glClearColor(1, 0, 0, 1);
  }

  private void createProjectionMatrix() {
    float aspectRatio = ((float) Display.getWidth()) / ((float) Display.getHeight());
    float yScale = (float) (1 / Math.tan(Math.toRadians(FOV / 2)) * aspectRatio);
    float xScale = yScale / aspectRatio;
    float frustumLength = farPlane - nearPlane;

    projMatrix = new Matrix4f();
    projMatrix.m00 = xScale;
    projMatrix.m11 = yScale;
    projMatrix.m22 = -((farPlane + nearPlane) / frustumLength);
    projMatrix.m23 = -1;
    projMatrix.m32 = -((2 * nearPlane * farPlane) / frustumLength);
    projMatrix.m33 = 0;

  }

  public void render(Entity e, Shader s) {
    TModel model = e.getModel();
    RawModel raw = model.getRawModel();
    GL30.glBindVertexArray(model.getRawModel().getVaoID());
    GL20.glEnableVertexAttribArray(0);
    GL20.glEnableVertexAttribArray(1);

    Matrix4f tMatrix = Maths.createTransformMatrix(e.getPos(), e.getRotX(), e.getRotY(), e.getRotZ(), e.getScale());
    s.loadTransformationMatrix(tMatrix);

    GL13.glActiveTexture(GL13.GL_TEXTURE0);
    GL11.glBindTexture(GL11.GL_TEXTURE_2D, model.getTexture().getId());

    GL11.glDrawElements(GL11.GL_TRIANGLES, raw.getVertexCount(), GL11.GL_UNSIGNED_INT, 0);

    GL20.glDisableVertexAttribArray(0);
    GL20.glDisableVertexAttribArray(1);

    GL30.glBindVertexArray(0);
  }

}
