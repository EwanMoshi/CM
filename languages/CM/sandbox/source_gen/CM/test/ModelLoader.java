package CM.test;

/*Generated by MPS */

import java.io.FileReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.BufferedReader;
import java.util.List;
import java.util.ArrayList;
import org.lwjgl.util.vector.Vector3f;
import org.lwjgl.util.vector.Vector2f;

public class ModelLoader {

  public static RawModel loadModel(String file, Loader l) {
    FileReader filereader = null;
    try {
      filereader = new FileReader(new File("models/" + file + ".obj"));
    } catch (FileNotFoundException e) {
      System.out.println("don't think so");
      e.printStackTrace();
    }
    BufferedReader bufferedreader = new BufferedReader(filereader);
    String line;
    List<Integer> indices = new ArrayList<Integer>();
    List<Vector3f> norms = new ArrayList<Vector3f>();

    List<Vector2f> tex = new ArrayList<Vector2f>();
    List<Vector3f> vertices = new ArrayList<Vector3f>();

    float[] verticesArray = null;
    float[] normsArray = null;
    float[] texArray = null;
    int[] indicesArray = null;
    try {
      while (true) {
        line = bufferedreader.readLine();
        String[] current = line.split(" ");
        if (line.startsWith("v ")) {
          Vector3f vertex = new Vector3f(Float.parseFloat(current[1]), Float.parseFloat(current[2]), Float.parseFloat(current[3]));
          vertices.add(vertex);
        } else if (line.startsWith("vt ")) {
          Vector2f texture = new Vector2f(Float.parseFloat(current[1]), Float.parseFloat(current[2]));
          tex.add(texture);
        } else if (line.startsWith("vn ")) {
          Vector3f normal = new Vector3f(Float.parseFloat(current[1]), Float.parseFloat(current[2]), Float.parseFloat(current[3]));
          norms.add(normal);
        } else if (line.startsWith("f ")) {
          texArray = new float[vertices.size() * 2];
          normsArray = new float[vertices.size() * 3];
          break;
        }
      }
      while (line != null) {
        if (!(line.startsWith("f "))) {
          line = bufferedreader.readLine();
          continue;
        }
        String[] currentL = line.split(" ");
        String[] v1 = currentL[1].split("/");
        String[] v2 = currentL[2].split("/");
        String[] v3 = currentL[3].split("/");

        processVert(v1, indices, tex, norms, texArray, normsArray);
        processVert(v2, indices, tex, norms, texArray, normsArray);
        processVert(v3, indices, tex, norms, texArray, normsArray);

        line = bufferedreader.readLine();

      }
      bufferedreader.close();

    } catch (Exception e) {
      e.printStackTrace();
    }
    verticesArray = new float[vertices.size() * 3];
    indicesArray = new int[indices.size()];

    int vp = 0;
    for (Vector3f v : vertices) {
      verticesArray[vp++] = v.x;
      verticesArray[vp++] = v.y;
      verticesArray[vp++] = v.z;
    }
    for (int i = 0; i < indices.size(); i++) {
      indicesArray[i] = indices.get(i);
    }
    return l.loadtoVAO(verticesArray, indicesArray, texArray);
  }

  private static void processVert(String[] vertexData, List<Integer> indices, List<Vector2f> tex, List<Vector3f> norms, float[] texArray, float[] normsArray) {
    int currentV = Integer.parseInt(vertexData[0]) - 1;
    indices.add(currentV);
    Vector2f curTex = tex.get(Integer.parseInt(vertexData[1]) - 1);
    texArray[currentV * 2] = curTex.x;
    texArray[currentV * 2 + 1] = 1 - curTex.y;
    Vector3f curNorm = norms.get(Integer.parseInt(vertexData[2]) - 1);
    normsArray[currentV * 3] = curNorm.x;
    normsArray[currentV * 3 + 1] = curNorm.y;
    normsArray[currentV * 3 + 2] = curNorm.z;
  }
}
